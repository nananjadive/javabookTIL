# 변수(야마)

### **1. 화면에 글자 출력하기**

### **print( )와 println( )**

**System.out.print()**의 경우, 괄호 안의 내용을 출력하고 줄바꿈

**System.out.println()**은 괄호 안의 내용을 출력하고 줄바꿈

****2. 덧셈, 뺄셈 계산하기****

### **3. 변수의 선언과 저장**

### **변수란?-"하나의 값을 저장할 수 있는 저장공간"**

하나의 변수에 단 하나의 값만 저장할 수 있고, 새로운 값을 저장하면 기존의 값은 사라진다.

### **1-2. 변수의 선언과 초기화**

-   **변수의 선언**

변수의 선언은 **"변수타입"**과 **"변수이름"**으로 선언

변수명 짓기

[변수명을 잘 짓기 위한 몸부림](https://brunch.co.kr/@wapj2000/29)

`int age;`

• **변수의 초기화**

변수를 선언한 이후부터는 변수를 사용,그 전에 반드시 변수를 **"초기화"**

`int age = 25; // 변수 age를 선언하고 25로 초기화 한다`

_`//예제 2-1/ch2/VarEx1.java`_

**`public** **class** VarEx1 {`

**`public** **static** **void** main(String[] args) {`

**`int** year = 0;`

**`int** age = 14;`

`System.out.println(year);`

`System.out.println(age);`

`year = age + 2000; *// 변수 age의 값에 2000을 더해 변수 year에 저장*`

`age = age + 1; *// 변수 age에 저정된 값을 1 증가시킨다.*`

`System.out.println(year);`

`System.out.println(age);`

`}`

`}`

_`//예제2-2/초2/VarEx2.java`_

```java
**public** **class** VarEx2 {

**public** **static** **void** main(String[] args) {

**int** x = 10 , y = 20;

**int** tmp = 0;

System.out.println("x:" + x + " y:" + y);

tmp = x; *//x는 10인데 10을 tmp에 넣어준다 -> tmp=10*

x = y; *// y값을 x에 넣어준다. x = 20*

y = tmp; *// tmp값을 y에 넣어준다. 위에서 tmp=10이므로 y=10*

System.out.println("x:" + x + " y:" + y);    *//실행결과    x:10 y:20*

}                                                *//          y:20 x:10*

}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ffe267a0-74a1-4c51-adec-7e010c630059/Untitled.png)

### ****1-3. 변수의 명명규칙****

1.  대소문자가 구분되며 길이에 제한이 없다.
    
2.  예약어를 사용해서는 안 된다.
    
3.  숫자로 시작해서는 안 된다.
    
4.  특수문자는**'_'**와**'$**'만을 허용한다.
    

-자바프로그램에서 권하는 규칙

1.  클래스의 이름의 첫 글자는 항상 대문자로 한다.
    
2.  여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. (카멜표기법)
    
3.  상수의 이름은 모두 대분자로한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
    

-알기쉽고 의미있는 이름

### **1-4. 변수의 타입**

자료형은 크게 **"기본형"**과 **"참조형"** 두 가지로 나뉜다.

**기본형은 실제 값(data)**를 저장하고, **참조형은 값이 저장되어있는 메모리 공간의 주소(address)**를 값으로 갖는다.

### **(1) 기본형(Primitive Type) : 8가지**

-   boolean

**② 문자형**

-   char(character)

**③ 정수형**

-   byte
-   short
-   int(integer)
-   long

**④ 실수형**

-   float
-   double

****(2) 참조형 : 기본형 이 외****

**String : 문자열(여러 문자)**

### **5. 상수와 리터럴**

### **(1) 변수(variable)**

**"하나의 값을 저장하기 위한 공간"**

### **(2) 상수(constant)**

**"값을 한번만 저장할 수 있는 공간",** 변수의 타입 앞에 **키워드 'final'** 상수의 이름은 **모두 대문자**로 하는 것이 관례

`// 상수 선언 시 변수타입 앞에 "final"을 붙여주면 된다 final int MAX_SPEED = 10;`

변수 : 하나의 값을 저장하기 위한 공간

상수 : 값을 한번만 저장할 수 있는 공간

리터럴 : 그 자체로 값을 의미하는 것

### **(3) 리터럴(literal)-"그 자체로 값을 의미하는 것"**

### **1) 논리형**

**① 리터럴** : true, false

**② 접미사** : 없음

### **(2) 정수형**

**① 리터럴**

-   10진수 ex) 10, 11, 12 ...
    
-   2진수(0b) ex) 0101 = 5(10진수)
    
    0b
    
-   8진수(0) ex) 77 = 63(10진수)
    
    0
    
-   16진수(0x) ex) FF = 255(10진수)
    
    0x
    

**② 접미사**

-   long타입 접미사 : l or L
-   기본형(접미사X) : int

### **(3) 실수형**

float와 double, 2가지가 있습니다. 연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위라던가 더 높은 정밀도를 필요로 한다면 double을 선택해야 한다.

**① 접미사**

-   float타입 접미사 : f or F
-   double타입(기본형) 접미사 : d or D

_//예제2-10/ch2/FloatEx1.java_

**public** **class** FloatEx1 {

**public** **static** **void** main(String[] args) {

**float** f = 9.123456878901234567890f;

**float** f2 = 1.2345678901234567890f;

**double** d = 9.12345678901234567890d;

System.out.printf(" 123456789012345678901234%n");

System.out.printf("f : %f%n", f);_//소수점 이하 6째자리까지 출력/7자리에서 반올림되서 출력된다._

System.out.printf("f : %24.20f%n", f2);

System.out.printf("f2 : %24.20f%n", f2);

System.out.printf("d : %24.20f%n", d);

}

}

_//예제2-11/ch2/FloatToBinEx.java_

**public** **class** FloatToBinEx {

**public** **static** **void** main(String[] args) {

**float** f = 9.1234567f;

**int** i = Float.floatToIntBits(f);_//floatToIntBits()는 float타입값을 int타입값으로 해석해서 반환해준다._

System.out.printf("%f%n", f);

System.out.printf("%X%n", i); _//16진수로 출력_

}

}

### **7. 문자 리터럴과 문자열 리터럴**

### **(4) 문자형(char 타입)**

**① 리터럴**

' '(작은 따옴표)로 문자 하나를 감싼 것

**※ ''안에 반드시 하나의 문자가 있어야 합니다.**

**② 접미사** : 없음

### **(5) 문자열(String 타입)**

**① 리터럴**

""(큰 따옴표)로 두 문자 이상을 감싼 것, 빈문자열을 허용

**② 접미사** : 없음

****8. 문자열 결합****

**문자열 + any type → 문자열 + 문자열 → 문자열**

**any type + 문자열 → 문자열 + 문자열 → 문자열**

**※ 변수의 기본값과 초기화-변수의 초기화 -**“변수에 처음으로 값을 저장”

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3a365a0-2a24-468c-ad3c-a6d53ae1503a/Untitled.png)

-****타입의 불일치****

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통

하지만 타입이 달라도 **넓은 타입에 좁은 타입의 값을 저장하는 것은 허용**

_//예제 2-3/ch2/StringEx.java_

**public** **class** StringEx {

**public** **static** **void** main(String[] args) {

String name = "Ja" + "va";

String str = name + 8.0;

System.out.println(name); _// 결과 : Java_

System.out.println(str); _// 결과 : Java8.0_

System.out.println(7 + " ");

System.out.println(" " + 7);

System.out.println(7 + "");

System.out.println("" + 7);

System.out.println("" + "");

System.out.println(7 + 7 + "");

System.out.println("" + 7 + 7);

System.out.println(" " + 7 + 7);

}

}

'A'와 같이 작은따옴표로 문자 하나를 감싼 것을 '문자 리터럴'이라고 한다. 두 문장 이상은 큰 따옴표로 감싸야하며 '문자열 리터럴’이라고함

****9. 두 변수의 값 바꾸기****

****10. 기본형과 참조형****

****11. 기본형의 종류와 범위****

**①** **boolean**은 **true와 false** 두 가지 값만 표현할 수

있으면 되므로 가장 작은 크기인 **1byte**입니다.

**②** **char**은 Java에서 **2byte 문자체계인 유니코드**를

사용하고 있으므로 **2byte**입니다.

**③** **기본형 int(4byte)**를 기준으로

짧으면 **short(2byte)**, 길면 **long(8byte)**입니다.

**④** **flaot(4byte)**의 두 배(double)인

**double**은 **8byte**입니다.

**⑤** **byte < short = char < int < long < float < double**

### **12. printf( )를 이용한 출력**

이전에 배운 **print()나 println()**은

**변수의 값을 그대로 출력**하는 반면,

**printf()**의 경우, **지시자(specifier)를 통해**

**변수의 값을 여러 가지 형식으로**

**변환하여 출력**합니다.

### **자주 사용하는 지시자**

**① %d :** 정수의 형식(10진수)으로 출력

**② %x :** 정수의 형식(16수)으로 출력

**③ %f :** 실수의 형식으로 출력

**④ %c :** 문자(character)로 출력

**⑤ %s :** 문자열(string)으로 출력

**⑥ %n :** 줄바꿈

****13. printf()를 이용한 출력(예제)****

//예제2-4/ch2/PrintfEx1.java ublic class PrintfEx1 { public static void main(String[] args) { byte b = 1; short s = 2; char c = 'A';

```
    int finger = 10;
    long big = 100_000_000_000L; //long big = 100000000000
    long hex = 0xFFFF_FFFF_FFFF_FFFFL;

    int octNum = 010;
    int hexNum = 0x10;
    int binNum = 0b10;

    System.out.printf("b = %d%n", b); // b = 1
    System.out.printf("s = %d%n", s); // s = 2
    System.out.printf("c = %c, %d %n", c, (int)c); // c = A, 65   %d가 왜 65가 나왔냐? 영문 대문자 'A'는 숫자 65를 뜻함
    System.out.printf("finger = [%5d]%n", finger); // finger = [   10]
    System.out.printf("finger = [%4d]%n", finger);//finger = [  10]
    System.out.printf("finger = [%3d]%n", finger);//finger = [ 10]
    System.out.printf("finger = [%d]%n", finger);// finger = [10]
    System.out.printf("finger = [%-5d]%n", finger);// finger = [10   ]
    System.out.printf("finger = [%05d]%n", finger); // finger = [00010]

    System.out.printf("big = %d%n", big);// big = 100000000000
    System.out.printf("hex = %x %n", hex); // hex = ffffffffffffffff    %x는 16진정수의 형식으로 출력
    System.out.printf("hex = %#x %n", hex);// hex = 0xffffffffffffffff  %x는 16진정수의 형식으로 출력 // #은 접두사 0x가 붙는다
    System.out.printf("hex = %#X %n", hex);// hex = 0XFFFFFFFFFFFFFFFF  %X는 16진정수의 형식으로 출력(대문자로출력)

    System.out.printf("octNum = %o, %d%n",octNum, octNum);// octNum = 10, 8    %o는 8진정수의 형식으로 출력 // 8진수 10, 10진수 8
    System.out.printf("hexNum = %x, %d%n", hexNum, hexNum);// hexNum = 10, 16
    System.out.printf("binNum = %s, %d%n", Integer.toBinaryString(binNum), binNum);// binNum = 10, 2
    //10진수를 2진수로 출력해주는 지시자는 없어 정수를 2진 문자열로 변환해주는 Integer.toBinaryString(int i)를 사용하고 이 메서드는 정수를
    //2진수로 변환해서 문자열로 반환하므로 지시자 %s를 사용함.
}

```

}

_//예제2-5/ch2/PrintEx2.java_

**public** **class** PrintfEx2 {

**public** **static** **void** main(String[] args) {

String url = "[www.codechobo.com](http://www.codechobo.com)";

**float** f1 = .10f;

**float** f2 = 1e1f;

**float** f3 = 3.14e3f;

**double** d = 1.23456789;

System.out.printf("f1 = %f, %e, %g%n", f1, f2, f3);

System.out.printf("f2 = %f, %e, %g%n", f2, f2, f2);

System.out.printf("f3 = %f, %e, %g%n", f3, f3, f3);

System.out.printf("d = %f%n", d);

System.out.printf("d = %14.10f%n", d); _//전체 14자리 중 소수점 10자리_

System.out.printf("[12345678901234567890]%n");

System.out.printf("[%s]%n", url);

System.out.printf("[%20s]%n", url);

System.out.printf("[%-20s]%n", url);_//왼쪽 정렬_

System.out.printf("[%.8s]%n", url);_// 왼쪽에서 8글자만 출력_

}

}

### **14. 화면으로부터 입력받기**

### **(1) Scanner란?**

**"화면으로부터 데이터를 입력받는**

**기능을 제공하는 클래스"**

### **(2) Scanner를 사용하는 방법**

**① import문 추가**

import java.util.Scanner;

(단축키 Shift + Ctrl + O)

```jsx
*import java.util.*;  //Scanner클래스를 사용하기 위해 추가*
```

**② Scanner 객체 생성**

Scanner sc = new Scanner([System.in](http://System.in));

```jsx
*Scanner scanner = new Scanner(System.in);  // Scanner클래스의 객체를 생성*
```

**③ Scanner 객체 사용**

-   int n1 = sc.nextInt();

(화면에서 입력받은 정수를 n1에 저장)

-   float f1 = sc.nextFloat();

(화면에서 입력받은 실수를 f1에 저장)

-   String str = sc → 줄(행) 단위
    
    .nextLine();
    

String str = sc.next(); → 띄어쓰기 단위

(화면에서 입력받은 내용을 str에 저장)

↓

int n1 = Integer.parseInt(str);

문자열(str)을 숫자(n1)으로 변환

```jsx
String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
```

```jsx
int num = Integer.parseInt(input); // 입력받은 내용을 int 타입의 값으로 반환
```

_//예제 2-6/ch2/ScannerEx.java_

**import** java.util.*; _//Scanner를 사용하기 위해 추가_

**public** **class** ScannerEx {

**public** **static** **void** main(String[] args) {

Scanner scanner = **new** Scanner([System.in](http://System.in)); _// Scanner클래스의 객체를 생성_

System.out.print("두자리 정수를 입력하세요 : ");

String input = scanner.nextLine(); _// 입력받은 내용을 input에 저장_

**int** num = Integer.parseInt(input); _//입력받은 문자열을 숫자로 변환_

_//입력받은 문자열을 숫자(int타입의 정수)로 변환하려면,Interger.parseInt() 메서드를 이용_

System.out.println("입력내용 :" + input);

System.out.printf("num = %d%n", num);

}

}

### **15. 정수형의 오버플로우**

### **오버플로우**

**"타입이 표현할 수 있는 범위를 넘어서는 것"**

### **최댓값 + 1 → 최솟값**

### **최댓값 + 1 → 최댓값**

### **16. 부호있는 정수형의 오버플로우**

부호가 없는 정수는 2진수로 '0000'이 될 때 오버플로우가 발생하고, **부호가 있는 정수는 부호 비트가 0에서 1이 될 때 오버플로우가 발생한다.**

### **(1) 부호가 없는 정수**

ex) 4bit

최댓값 : 1111 (15)

최솟값 : 0000 (0)

### **(2) 부호가 있는 정수**

ex) 4bit

**최댓값 : 0111 (7)**

**최솟값 : 1111 (-8)**

_//예제2-9/ch2/OverflowEx.java_

**public** **class** OverflowEx {

**public** **static** **void** main(String[] args) {

**short** sMin = -32768;

**short** sMax = 32767;

**char** cMin = 0;

**char** cMax = 65535;

System.out.println("sMin = " + sMin);

System.out.println("sMin-1" + (**short**)(sMin-1));

System.out.println("sMax = " + sMax);

System.out.println("sMax+1" + (**short**)(sMax+1));

System.out.println("cMin = " + (**int**)cMin);

System.out.println("cMin-1 = " + (**int**)cMax);

System.out.println("cMax = " + (**int**)cMax);

System.out.println("cMax+1= " + (**int**)++cMax);

}

}

_sMin = -32768_

_sMin-1 = 32767_

_sMax = 32767_

_sMax+1 = -32768_

_cMin = 0_

_cMin-1 = 65535_

_cMax = 65535_

_cMax+1 = 0_

### **17. 타입 간의 변환방법**

**형변환(Casting)**

**"값의 타입을 다른 타입으로 변환하는 것"**

**변수 또는 상수(리터럴)의 타입을 다른 타입으로 변환하는 것**

형 변환의 방법은 아주 간단한데, 형 변환하고자 하는 변수나 리터럴 앞에 타입을 괄호와 함께 붙여주면 된다.

`// 형 변환 방법 : 타입(피연산자) double d = 85.4; int score = (int)d; // double타입의 변수 d를 int타입으로 변환`

_//예제2-12/ch2/CastingEx1.java_

**public** **class** CastingEx1 {

**public** **static** **void** main(String[] args) {

**double** d = 85.4;

**int** score = (**int**)d;

System.out.println("score = " + score); _//결과 : score = 85_

System.out.println("d = " +d); _// 결과 : d = 85.4_

}

}

기본형(primitive typte)에서 boolean을 제외한 나머지 타입들은 서로 형 변환이 가능하다.

@ float타입의 값을 int타입으로 변환할 때 소수점 이하의 값은 반올림이 아닌 버림 처리가 된다.@

**큰 타입에서 작은 타입으로 변환**할 때는 타입의 크기가 작아지기 때문에 크기의 차이만큼 값이 잘려나간다.그래서 경우에 따라 **값 손실이 발생**

****자동 형 변환****

범위가 큰 타입간의 대입이나 연산을 할 때, 형 변환으로 타입을 일치시키는 것이 원칙의성을 위해 **형 변환을 생략할 수 있다.**

`double d = 1234; // 에러 X, double d = (float)1234; 와 동일 byte b = 1000; // 에러 O, 1000은 byte 범위(-128~127)을 넘어감`

byte 예시의 에러를 해결하려면 처음 배운 **명시적 형 변환**으로 선언-값손실이 있어도 에러발생 x

연산 시에도 자동 형 변환이 이루어지는데, 연산되는 두 타입 중 더 넓은(큰) 타입으로 형 변환하여 타입을 일치시킨 후 연산

`int a = 10; double b = 1.1 + a; // 형변환을 하지 않아도 더 큰 타입인 double형으로 연산되어 반환`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb6fb7de-ba15-41d9-9ddc-bdacdabba466/Untitled.png)

### 정수형 간의 형 변환

큰 타입에서 작은 타입으로의 변환에서는 값 손실이 발생할 수 있다.

_//예제2-13/ch2/CastingEx2.java_

**public** **static** **void** main(String[] args) {

**int** i = 10;

**byte** b = (**byte**)i;

System.out.printf("[int -> byte] i=%d -> b=%d%n", i, b);

i = 300;

b = (**byte**)i;

System.out.printf("[int -> byte] i=%d -> b=%d%n", i, b);

b = 10;

i = (**int**)b;

System.out.printf("[byte -> int] b=%d -> i=%d%n", b, i);

b = -2;

i = (**int**)b;

System.out.printf("[byte -> int] b=%d -> i=%d%n", b, i);

System.out.println("i = " + Integer.toBinaryString(i));

}

}

_//결과_

_//[int -> byte] i=10 -> b=10_

_//[int -> byte] i=300 -> b=44_

_//[byte -> int] b=10 -> i=10_

_//[byte -> int] b=-2 -> i=-2_

_//i = 11111111111111111111111111111110_

### 실수형 간의 형 변환

실수형에서도 정수형처럼 작은 타입에서  큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다. float타입의 값을 double으로 변환하는

경우, 지수(E)는 float의

` 기저인 127을 뺀 후 double 기저인 1023을 더해서 변환하고, 가수(M)는 float의 가수 23자리를 채우고 남은

자리를 0으로 채운다.

```java
Copy
//예제2-14/ch2/CastingEx3.java
publicclass CastingEx3 {

publicstaticvoid main(String[] args) {

float f = 9.1234567f;

double d = 9.1234567;

double d2 = (double)f;

        System.out.printf("f = %20.18f\\n", f);

        System.out.printf("d = %20.18f\\n", d);

        System.out.printf("d2 = %20.18f\\n", d2);

    }

}

//결과
// f = 9.123456954956055000
// d = 9.123456700000000000
// d2 = 9.123456954956055000

```

기존의 값을 최대한 보존할 수 있는 타입으로 자동 형 변환한다.

1.  boolean을 제외한 나머지 7개의

**기본형은 서로 형 변환이 가능**하다.

2.  기본형과 참조형은 서로 형 변환할 수 없다.
    
3.  서로 다른 타입의 변수간에 연산은 형 변환을 하는 것이 원칙이지만, **값의 범위가 작은 타입에서 큰 타입으로의 형 변환은 생략할 수 있다.**

# 연산자(야마)

**1. 연산자(operator)**

**1.1 연산자와 피연산자**

*_연산자(operator) 연산을 수행하는 기호(+, -, _, / 등)__

**피연산자(operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)**

**1.3 연산자의 종류**

**# 연산자의 기능별 분류**

*_종류연산자설명산술연산자+ - * / % << >>사칙연산(+, -, _, /)과 나머지 연산(%)비교연산자> < >= <= == !=크고 작음과 같고 다름을 비교논리연산자&& || !'그리고(AND)와 "또는(OR)'으로 조건을 연결비트연산자& | ^ ~피연산자를 비트단위로 논리 연산대입연산자=우변의 값을 좌변에 저장기타(type) ?: instanceof형변환 연산자, 삼항 연산자, instanceof 연산자__

**# 피연산자의 개수에 의한 분류**

**ex)**

```
-3-5
```

-   **첫 번째 -는 부호 연산자, 단항 연산자**
-   **두 번째 -는 뺄셈 연산자, 이항 연산자**

**1.4 연산자의 우선순위와 결합규칙**

**가장 높은 것 ()**

**가장 낮은 것 =**

**# 연산자 우선순위의 예시와 설명 (><로 우선순위 여부 표시)**

-   **단항 연산자 > 이항 연산자**

**ex) -x + 3**

-   **곱셈/나눗셈 > 덧셈/뺄셈**

**ex) x + 3 * y**

-   **산술연산자(+, -) > 비교연산자(>)**

**ex) x + 3 > y - 2**

-   **비교연산자 > 논리연산자 &&**

**ex) x > 3 && x < 5**

-   **대입연산자는 우선순위가 가장 낮다**

**ex) result = x + y * 3;**

-   **덧셈연산자 > shift연산자(<<)**

**ex) x << 2 + 1**

-   **비교연산자(==) > 비트연산자(&)**

**ex) data & 0xFF == 0 (문법적에러 발생되는 예시임 - true, false로는 비트연산이 불가하기 때문!)**

-   **AND(&, &&) > OR(|, ||)**

**ex) x < -1 || x > 3 && x < 5**

**# 연산자의 결합규칙**

**연산자마다 다르지만, 대부분 왼쪽 → 오른쪽 순으로 연산을 수행하고,**

**단항연산자와 대입연산자만 오른쪽 → 왼쪽 순으로 연산을 수행한다.**

-   **연산자의 우선순위와 결합규칙 정리 표**

__종류결합규칙연산자우선순위단항연산자←++ -- + - ~ ! (type)높음낮음산술연산자→_ / %→+ -→<< >>비교연산자→< > <= >= instanceof→== !=논리연산자→&→^→|→&&→||삼항연산자→?:대입연산자←= += -= _= /= %= <<= >>= &= ^= |=__

**1.5 산술변환(usual arithmetic conversion)**

**연산 수행 직전에 발생하는 피연산자의 자동 형변환**

-   **산술변환 규칙**

**① 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)**

```

long +int →long +long →long
float +int →float +float →float
double +float →double +double →double
```

**② 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.**

```

byte +short →int +int →int
char +short →int +int →int
```

**2. 단항연산자**

**2.1 증감연산자(++, --)**

**피연산자에 저장된 값을 1 증가 또는 1 감소시킨다.**

-   **전위형과 후위형의 비교**

**타입설명예시전위형값이 참조되기 전에 증가시킨다.j = ++i;  → ++i;  // 증가 후                 j = i;    참조하여 대입후위형값이 참조된 후에 증가시킨다.j = i++; → j = i; // 참조하여 대입 후              ㅑ++;    증가**

**2.2 부호연산자(+, -)**

**피연산자의 부호를 반대로 변경한 결과를 반환한다.**

**피연산자가 음수면 양수, 양수면 음수가 연산 결과가 된다.**

**3. 산술연산자**

*_3.1 사칙연산자(+, -, _, /)__

-   **정수형은 나눈 결과에서 소수점 이하는 버려진다.**

**ex) int 10 / int 4 → int 2**

-   **크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동형변환 되지만,**

**반대로 크기가 큰 자료형의 값을 작은 자료형의 변수에 저장하려면**

**명시적으로 형변환 연산자를 사용해서 변환해주어야 한다.**

**# 숫자와 영문자의 유니코드표**

**문자코드문자코드문자코드048A65a97149B66b98250C67c99351D68d100452E69e101553................X88x120856Y89y121957Z90z122**

**// Tip : 유니코드를 모를 땐**

**ex) char ch = 'A';**

**System.out.print((int)ch); 를 작성해 확인해보기!**

-   **리터럴, 상수 간의 연산은 형변환 해주지 않아도**

**실행과정동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산하여 그 결과로 대체한다.**

**이로 인해, 코드를 보다 효율적으로 만들어준다.**

**반대로 코드의 가독성과 유지보수를 위해서 일부러 뻔한 리터럴 연산을 풀어쓰는 경우도 있다.**

**풀어쓰더라도 컴파일러에 의해 미리 계산되기 때문에 실행 시 성능차이는 없다.**

**ex)**

*_컴파일 전의 코드컴파일 후의 코드char c2 = 'a'+1;int sec = 60 * 60 _24;char c2 = 'b';int sec = 86400;__

**↕**

**char c2 = c1 + 1; → char c2 = (char)(c1+1); // 변수 간의 연산**

**# 버림 / 반올림**

-   **버림**

**ex)**

```

classOperatorEx16{
publicstaticvoidmain(String[] args) {
float pi =3.141592f;
float shortPi = (int)(pi*1000) /1000f;
			System.out.println(shortPi);// 결과 : 3.141
		}
	}
```

**int형 간의 나눔셈을 수행하면 결과는 int가 된다.(float나 double 아님 주의)**

**또한 나눗셈의 결과를 반올림 하는 것이 아니라 버림한다.**

-   **반올림**

**ex)**

```

classOperatorEx17{
publicstaticvoidmain(String[] args) {
double pi =3.141592f;
double shortPi = (int)(pi *1000 +0.5) /1000.0;
			System.out.println(shortPi);// 결과 : 3.142
		}
	}
```

**반올림을 위해 0.5를 더해줌**

-   **Math.round() : 매개변수로 받은 값을 소수점 첫째자리에서 반올림 하고 그 결과를 정수로 돌려주는 메소드**

**위의 반올림 방법보다 더 간단히 처리할 수 있다.**

**ex)**

```

classOperatorEx18{
publicstaticvoidmain(String[] args) {
double pi =3.141592;
double shortPi = Math.round(pi *1000) /1000.0;
			System.out.println(shortPi);// 결과 : 3.142
		}
	}
```

**★ Math.round() : 반올림**

**Math.ceil() : 올림 (천장)**

**Math.floor() : 내림 (바닥)**

**위의 세 가지 메소드들은 무조건 소수점 이하가 있는 경우 해당 메소드를 실행한다.**

**실제 코딩 시 많이 사용하므로 암기해두자!**

**Q. 사용자로 부터 문자하나를 입력받아,**

**입력받은 값이 숫자이면, '숫자', 소문자이면, '소문자', 대문자이면 '대문자'라고 출력하자. (자바의 정석 p.117)**

```

Scanner scanner =new Scanner(System.in);
char ch =' ';
System.out.println("문자를 하나 입력하세요.>");

String input = scanner.nextLine();
ch = input.charAt(0)
```

**A.**

```

import java.util.Scanner;

publicclassOperator {
publicstaticvoidmain(String[] args) {
	Scanner scanner =new Scanner(System.in);
char ch =' ';
	System.out.println("문자를 하나 입력하세요.>");
while(true) {
	String input = scanner.nextLine();
	ch = input.charAt(0);

if(input.length() ==1) {
		scanner.close();
break;
	}
else {
		System.out.println("한 글자만 입력해주세요.");
	  	System.out.println("다시 입력해주세요.");
		}
	}
if('0' <= ch && ch <='9')
		System.out.println("숫자");
elseif('a'<= ch && ch <='z')
		System.out.println("소문자");
elseif ('A'<=ch && ch <='Z')
		System.out.println("대문자");
	scanner.close();
	}
}

```

**3.2 나머지 연산자 (%)**

**왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자**

**나누는 수로 음수도 허용한다.**

**따라서 피연산자의 부호를 모두 무시하고,**

**나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.**

**4. 비교 연산자**

**4.2 등가비교 연산자( ==, !=)**

-   **== : 두 값이 같으면 true, 아니면 false**
-   **!= : 두 값이 다르면 true, 아니면 false**

**// Tip : >=와 같이 두 개의 기호로 이루어진 연산자는**

**기호의 순서 바꾸는 것과 중간에 공백이 있는 것을 허용하지 않는다.**

**ex) 10.0 = 10.0f의 결과는 false인데**

**이는 정수형과 달리 실수형은 근사값으로 저장되므로 오차가 발생할 수 있기 때문이다.**

**# 문자열의 비교 (equals())**

**  equals 메소드는 비교하고자 하는 대상의 내용 자체를 비교**

**== 연산자는 비교하고자 하는 대상의 주소값을 비교**

**5. 논리연산자**

**5.1 논리연산자( &&, ||, !)**

-   **|| (OR 결합) : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.**
-   **&& (AND 결합) : 피연산자 양쪽 모두 true여야 true를 결과로 얻는다.**

**# 효율적인 연산 - Short Circuit Evaluation(SCE, 숏 서킷 연산 :  연산생략)**

** AND 혹은 OR 의 연산에 있어서 결과가 확실하게 예측이 되었을 때**

**뒤에 나머지 연산을 실행하지 않고 답을 내버리는 경우를 의미**

**# 논리 부정 연산자(!)**

**!true = false**

**5.2 비트연산자( &, |, ^, ~, <<, >> )**

-   **| (OR연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.**
-   **& (AND연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.**
-   **^ (XOR연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.**

**Q. 사용자로 부터 int형 정수하나를 입력받아, 그 값을 4byte 이진수 형태로 출력하자. (자바의 정석 p.122)**

**ex)**

**10진 정수를 입력하세요. 10 2진수 00000000000000000000000000001010**

**[참고] Integer.toBinaryString(10); 를 이용해보시오.**

```

class OperatorEx28{
		public static void main(String[] args) {
intx =0xAB,y =0xF;

			System.out.printf("x = %#X \\t\\t%s%n",x, toBinaryString(x));
			System.out.printf("y = %#X \\t\\t%s%n",y, toBinaryString(y));
			System.out.printf("%#X | %#X = %#X \\t%s%n",x,y,x |y, toBinaryString(x |y));
			System.out.printf("%#X & %#X = %#X \\t%s%n",x,y,x &y, toBinaryString(x &y));
			System.out.printf("%#X ^ %#X = %#X \\t%s%n",x,y,x ^y, toBinaryString(x ^y));
			System.out.printf("%#X ^ %#X ^ %#X = %#X \\t%s%n",x,y,y,x ^y ^y, toBinaryString(x ^y ^y));
		}

		static String toBinaryString(intx) {
			String zero ="00000000000000000000000000000000";
			String tmp = zero + Integer.toBinaryString(x);
return tmp.substring(tmp.length()-32);
		}

```

**# 비트 전환 연산자 (~)**

**피연산자를 2진수로 표현했을 때, 0은 1로 1은 0으로 바꾼다.**

**논리부정 연산자(!)와 유사하다.**

**# 쉬프트연산자(<<, >>)**

**피연산자의 각 자리(2진수로 표현했을 때)를 '오른쪽(>>)' 또는 '왼쪽(<<)'으로 이동(shift)한다.**

**ex) 8<<2 : 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다.**

**빈칸은 0으로 채운다.**

**8>>2 : 10진수 8의 2진수를 오른쪽으로 2자리 이동한다.**

**빈칸은 음수인 경우 1, 양수는 0으로 채운다.**

**6. 그 외의 연산자**

**6.1 조건연산자 ?: (= 삼항연산자)**

**자바 내 유일한 삼항연산자이다.**

```

 조건식? 식1 : 식2
        (참)   (거짓)
```

**ex) absX = x >=0? x : -x;**

**6.2 대입연산자 (=, op=)**

**변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용**

**# 복합대입연산자**

연습문제 , 해답

class Exercise3_1 { public static void main(String[] args) { int x = 2; int y = 5; char c = 'A'; // 'A'의 문자코드는 65 System.out.println(1 + x << 33); System.out.println(y >= 5 || x < 0 && x > 2); // &&가 우선순위가 높음 System.out.println(y += 10 - x++); // 후치로 증가하지만 연산 시 증가 전인 2 System.out.println(x+=2); // 5 System.out.println( !('A' <= c && c <='Z') ); // 대문자 여부 검사 수식, !true = false System.out.println('C'-c); // 67 - 65 = 2 System.out.println('5'-'0'); // 53 - 48 = 5 System.out.println(c+1); System.out.println(++c); // b System.out.println(c++); // b System.out.println(c); // c } }

**A.**

```java
System.out.println(1 + x <<33);// 결과 : 6
```

**A.**

```java
System.out.println(y >= **5** **||** x < **0**&& x > **2**); **//**결과 : **true**
```

```java
System.**out**.println( !(**'A'** <= c && c <=**'Z'**) ); ***// 결과 : false***
```

```
System.out.println('C'-c);// 결과 : 2
```

**이항연산자는 피연산자가 int보다 작은 타입(byte, short, char)인 경우 int로 변환한 다음에 연산을 수행한다.**

```
System.out.println('5'-'0');// 결과 : 5
```

**'5'-'0'도 위와 같은 이유로 '53 - 48'이 되어 5를 결과로 얻는다.**

```
System.out.println(c+1);// 결과 : 66
```

**c+1은 c의 값이 'A'이므로 'A'+1이 되고, 이항연산자의 성질(int보다 작은 타입은 int로 변환 후 연산)때문에**

**'A'는 문자코드 값인 65로 변환되어 '65 + 1'을 수행하여 66을 결과로 얻는다.**

```
System.out.println(++c);// 결과 : B
```

**단항연산자인'++'은 이항연산자와 달리 int보다 작은 타입도 형변환을 하지 않는다.**

```
System.out.println(c++);// 결과 : C
```

**단항연산자'++'이 후위형인 경우에는 println()에 의해서 변수 c가 출력된 후에 c에 저장된 값이 증가**

**Q2. 아래의 코드는 사과를 담는데 필요한 바구니(버켓)의 수를 구하는 코드이다.**

**만일 사과의 수가 123개이고 하나의 바구니에는 10개의 사과를 담을 수 있다면,**

**13개의 바구니가 필요할 것이다. (1)에 알맞은 코드를 넣으시오.**

```

classExercise3_2 {
publicstaticvoidmain(String[] args) {
int numOfApples =123;// 사과의 개수
int sizeOfBucket =10;// 바구니의 크기(바구니에 담을 수 있는 사과의 개수)
int numOfBucket = (/* (1) */ );// 모든 사과를 담는데 필요한 바구니의 수
		System.out.println("필요한 바구니의 수 :"+numOfBucket);// 결과 : 13
	}
}
```

**A. (1)의 해당 내용**

```
numOfApples/sizeOfBucket + (numOfApples%sizeOfBucket >0 ?1 :0)
```

**사과의 개수(numOfApples)를 바구니의 크기(sizeOfBucket)으로 나눗셈연산(/)을 하면**

**사과를 담는데 필요한 바구니의 수(numOfBucket)를 구할 수 있다.**

**Q3. 아래는 변수 num의 값에 따라 ‘양수’, ‘음수’, ‘0’을 출력하는 코드이다.**

**삼항 연산자를 이용해서 (1)에 알맞은 코드를 넣으시오.     [Hint] 삼항 연산자를 두 번 사용하라.**

```

classExercise3_3 {
publicstaticvoidmain(String[] args) {
int num =10;
		System.out.println(/* (1) */ );// 결과 : 양수
	}
}
```

**A. (1)의 해당 내용**

```
num >0 ?"양수":(num <0 ?"음수" :"0")
```

**Q4. 아래는 변수 num의 값 중에서 백의 자리 이하를 버리는 코드이다.**

**만일 변수 num의 값이 ‘456’이라면 ‘400’이 되고, ‘111’이라면 ‘100’이 된다.**

**(1)에 알맞은 코드를 넣으시오.**

```

classExercise3_4 {
publicstaticvoidmain(String[] args) {
int num =456;
		System.out.println(/* (1) */ );// 결과 : 400
	}
}
```

**A. (1)의 해당 내용**

```
num/100*100
```

**Q5. 아래는 변수 num의 값 중에서 일의 자리를 1로 바꾸는 코드이다.**

**만일 변수 num의 값이 333이라면 331이 되고, 777이라면 771이 된다.**

**(1)에 알맞은 코드를 넣으시오.**

```

classExercise3_5 {
publicstaticvoidmain(String[] args) {
int num =333;
		System.out.println(/* (1) */);// 결과 : 331
	}
}
```

**A. (1)의 해당 내용**

```
num/10*10+1
```

**Q6. 아래는 변수 num의 값보다 크면서도 가장 가까운 10의 배수에서**

**변수 num의 값을 뺀 나머지를 구하는 코드이다.**

**예를 들어, 24의 크면서도 가장 가까운 10의 배수는 30이다.**

**19의 경우 20이고, 81의 경우 90이 된다.**

**30에서 24를 뺀 나머지는 6이기 때문에 변수 num의 값이 24라면 6을 결과로 얻어야 한다.**

**(1)에 알맞은 코드를 넣으시오.     [Hint] 나머지 연산자를 사용하라.**

```

classExercise3_6 {
publicstaticvoidmain(String[] args) {
int num =24;
		System.out.println(/* (1) */);// 결과 : 6
	}
}
```

**A. (1)의 해당 내용**

```
10 - num%10
```

**Q7. 아래는 화씨(Fahrenheit)를 섭씨(Celcius)로 변환하는 코드이다.**

**변환공식이 'C =5/9 ×(F - 32)'라고 할 때, (1)에 알맞은 코드를 넣으시오.**

**단, 변환 결과값은 소수점 셋째자리에서 반올림해야한다.**

**(Math.round()를 사용하지 않고 처리할 것)**

```

classExercise3_7 {
publicstaticvoidmain(String[] args) {
int fahrenheit =100;
float celcius = (/* (1) */);
		System.out.println("Fahrenheit:"+fahrenheit);// 결과 : Fahrenheit:100
		System.out.println("Celcius:"+celcius);// 결과 : Celcius:37.78
	}
}
```

**A. (1)의 해당 내용**

```
(int)((5/9f * (fahrenheit -32))*100 +0.5) /100f;
```

**① 값에 100을 곱한다.      37.77778 * 100**

**② 1의 결과에 0.5를 더한다.      3777.778 + 0.5 → 3778.278**

**③ 2의 결과를 int타입으로 변환한다.      (int)3778,278 → 3778**

**④ 3의 결과를 100f로 나눈다.(100으로 나누면 소수점 아래의 값을 잃는다.)      3778 / 100f → 37.78**

**Q8. 아래 코드의 문제점을 수정해서 실행결과와 같은 결과를 얻도록 하시오.**

```

classExercise3_8 {
publicstaticvoidmain(String[] args) {
byte a =10;
byte b =20;
byte c = a + b;
char ch ='A';
		ch = ch +2;
float f =3 /2;
long l =3000 *3000 *3000;
float f2 =0.1f;
double d =0.1;
		boolean result = d==f2;
		System.out.println("c="+c);// 결과 : c=30
		System.out.println("ch="+ch);// 결과 : ch=C
		System.out.println("f="+f);// 결과 : f=1.5
		System.out.println("l="+l);// 결과 : l=27000000000
		System.out.println("result="+result);// 결과 : result=true
	}
}
```

**A.**

**이항연산은 두 피연산자의 타입을 일치시킨 후 연산을 수행한다는 것,**

**그리고 int보다 작은 타입은 int로 자동변환한다는 것은 반드시 기억하고 있어야 하는 중요한 내용이다.**

```
byte c = a + b; →byte c = (byte)(a + b);
```

**nt타입의 값(4 byte)을 byte타입의 변수(1 byte)에 담아야하므로 형변환을 해주어야한다.**

```
ch = ch +2; → ch = (char)(ch + 2);
```

```
float f = 3 / 2; →float f = 3 / 2f;
```

**int와 int의 연산결과는 int이기 때문에 3/2의 결과는 1이 된다.**

**연산결과를 실수로 얻고 싶으면, 적어도 두 피연산자 중 한 쪽이**

**실수 타입(float와 double중의 하나)이어야 한다.**

```
long l =3000 *3000 *3000; →long l =3000 *3000 *3000L;
```

**int_int_int의 결과는 int이므로**

**int타입의 최대값인 약 2*10의 9제곱을 넘는 결과는 오버플로우가 발생하여 예상한 것과는 다른 값을 얻는다.**

**// Tip : 좀 더 명확히 하기 위해선 모두 L을 붙여주는 것이 좋다.**

```
boolean result = d==f2; →boolean result = (float)d==f2;
```

**비교연산자도 이항연산자이므로 연산 시에 두 피연산자의 타입을 맞추기 위해 형변환이 발생한다.**

**그래서 double과 float의 연산은 double과 double의 연산으로 자동형변환 되는데,**

**실수는 정수와 달리 근사값으로 표현을 하기 때문에 float를 double로 형변환했을 때 오차가 발생할 수 있다.그래서 float값을 double로 형변환하기 보다는**

**double값을 유효자리수가 적은 float로 형변환해서 비교하는 것이 정확한 결과를 얻는다.**

**Q9. 다음은 문자형 변수 ch가 영문자(대문자 또는 소문자)이거나 숫자일 때만**

**변수 b의 값이 true가 되도록 하는 코드이다.**

**(1)에 알맞은 코드를 넣으시오.**

```

classExercise3_9 {
publicstaticvoidmain(String[] args) {
char ch ='z';
		boolean b = (/* (1) */ );
		System.out.println(b);// 결과 : true
	}
}
```

**A.**

```

('a' <= ch && ch <='z')|| ('A' <= ch && ch <='Z')
|| ('0' <= ch && ch <='9');
```

**Q10. 다음은 대문자를 소문자로 변경하는 코드인데,**

**문자 ch에 저장된 문자가 대문자인 경우에만 소문자로 변경한다.**

**문자코드는 소문자가 대문자보다 32만큼 더 크다.**

**예를 들어 'A‘의 코드는 65이고 ’a'의 코드는 97이다.**

**(1)~(2)에 알맞은 코드를 넣으시오.**

```

classExercise3_10 {
publicstaticvoidmain(String[] args) {
char ch ='A';
char lowerCase = (/* (1) */ ) ? (/* (2) */ ) : ch;
		System.out.println("ch:"+ch);// 결과 : ch:A
		System.out.println("ch to lowerCase:"+lowerCase);// 결과 : ch to lowerCase:a
	}
}
```

**A.**

```
('A' <= ch && ch <='Z'), (char)(ch+32)
```

덧**셈연산의 결과가 int이므로 char타입으로의 형변환이 필요하다.**

참고



# 조건문과 반복문(야마)


## **Chapter 4. 조건문과 반복문**

### **1. if문**

**제어문(control statment)**은 **프로그램의 흐름(flow)을 바꾸는 역할을 하는 문장**

제어문에는 조건문과 반복문이 있으며,**조건문**은 **조건에 따라다른 문장이 수행**되도록 하고, **반복문**은 **특정 문장들을 반복해서 수행**

**if문**은 가장 **기본적인 조건문**

의미는 **'만일(if) 조건식이 참(true)이면,**

**괄호{ } 안의 문장을 수행하라'**

예제 4_1

### **2. 조건식의 다양한 예**

**if문**에 사용되는 조건식은 **비교 연산자와 논리 연산자로 구성조건식의 결과**는 반드시

**true 또는 false**

예제 4_2

### **3. 블럭{ }**

**괄호{ }를 이용해서 여러 문장을하나의 단위로 묶는 것**을**블럭(block)**이라고 합니다.

블럭 안에는여러 문장을 넣을 수 있으며,한 문장만 넣거나, 아무것도 넣지 않을 수 있다.

만약, **블럭 안에 문장이 하나뿐일 경우, 괄호{ }는 생략가능**

### **4. if-else문**

**if-else문의 구조**는 아래와 같습니다.

![https://blog.kakaocdn.net/dn/F2C0F/btqS4Mn4IId/LrkEhNHVOpcMOvDz1fHHnK/img.png](https://blog.kakaocdn.net/dn/F2C0F/btqS4Mn4IId/LrkEhNHVOpcMOvDz1fHHnK/img.png)

**기존의 if문에 'else{ }'가 추가**된 형태이며,

**조건식의 결과가 참이 아닐 때,**

**else{ }의 괄호안 문장을 수행**하라는 뜻입니다.

![https://blog.kakaocdn.net/dn/bmk1Cm/btqS2949TNB/sdrCykaaPi3edMdgfj39E0/img.png](https://blog.kakaocdn.net/dn/bmk1Cm/btqS2949TNB/sdrCykaaPi3edMdgfj39E0/img.png)

예제 4_3

**단일 if문**

주어진 조건을 만족하는 경우에만 특정 문장을 수행하도록 하는 제어문

```
        System.out.println("문장1");
        int num = 0;
        if(3==13) {
            int num=10;
            System.out.println("문장2");
            System.out.println("문장2-1");
        }
        System.out.println(num);
        System.out.println("문장3");
```

주어진 조건 '3은 13과 같다'는 거짓이므로 괄호 안에 문장은 실행되지 않고 괄호 밖으로 나가서 num값인 0과 문장3이 출력된다. 주어진 조건이 참일 경우엔 num의 변수값을 10으로 바꿔주고 문장 2와 2-1이 출력된 후 10과 문장3까지 출력된다.

```
        int n=10;
        if(n>5) {
            System.out.println(n+"은 5보다 크다");
        }
        System.err.println("프로그램 종료");
```

n은 10이므로 주어진 조건식은 참이 되기 때문에 괄호안의 문장이 실행되고 프로그램 종료 문장이 출력된다.

### **5. if-else if문**

**if-else if문**은 **한 문장에 여러 개의**

**조건식을 사용가능**하게 합니다.

![https://blog.kakaocdn.net/dn/6PUWL/btqS1V7bd15/2gH43bBDIaPuFMojSVlOj0/img.png](https://blog.kakaocdn.net/dn/6PUWL/btqS1V7bd15/2gH43bBDIaPuFMojSVlOj0/img.png)

**if-else if문의 처리 과정**은

아래와 같습니다.

**① 결과가 참인 조건식을 만날 때까지첫번째 조건식부터 순서대로 평가합니다.**

**② 참인 조건식을 만나면,해당 블럭{ }의 문장을 수행합니다.**

**③ if-else if문 전체를 빠져나옵니다.**

### **6. if-else if문 예제**

**"점수를 입력하면,**

**그에 해당하는 학점을 출력하는 코드"**

![https://blog.kakaocdn.net/dn/bPqGhq/btqSZxlcKzc/iL1flpibmOkIBxHx813J20/img.png](https://blog.kakaocdn.net/dn/bPqGhq/btqSZxlcKzc/iL1flpibmOkIBxHx813J20/img.png)

예제 4_4

**if-else문**

```
        System.out.println("문장1");
        int num = 0;//변수선언if(3==3) {
            num=3;//초기화
            System.out.println("참");
            System.out.println("참2");
            System.out.println(num);
        }else {
            System.out.println("거짓");
            System.out.println("거짓2");
        }
        System.out.println(num);
        System.out.println("문장3");
```

조건식이 참일 경우 if절 괄호 안 문장이 출력되고, 거짓일 경우 else 괄호 안 문장이 출력되며 괄호밖 문장은 조건에 상관없이 출력된다.

**다중 if~else문**

```
// 점수에 따라 등급 부여하기

        System.out.println("점수 입력하시오");
        Scanner scan = new Scanner(System.in);
        int num = scan.nextInt();
        if(num >= 90) {
            System.out.println("A");
        }else if(num >= 80) {
            System.out.println("B");
        }else if(num >= 70) {
            System.out.println("C");
        }else {
            System.out.println("F");
        }
        scan.close();
        System.out.println("문장3");
```

키보드로부터 입력받은 데이터를 출력하는 방법으로 Scanner 클래스를 사용할 수 있다. 두번째 코드와 같이 `스캐너타입 변수명 = new 스캐너실행함수();`로 Scanner 객체를 생성하면 빨간줄이 뜨는데, 클릭해서 `import.util`을 해줘야한다. 스캐너 함수 안에 있는 `System.in`은 입력한 값을 바이트 단위로 읽겠다는 의미다. 그 다음 `nextInt()`메소드를 사용하여 정수를 입력받아 num이라는 변수에 저장한다. 점수에 따라서 성적 등급을 프린트하는 다중 if~else조건문을 만든 후 `scan.close()`로 스캐너를 닫아준다.

## ←-문자열 비교—>

> 문자열 비교

비교연산자 `==` 와 `.equals()`메소드는 양쪽에 있는 수를 비교해서 boolean값을 반환한다. 하지만 ==은 변수가 가진 주소값을 비교하고, 이퀄 메소드는 변수가 가진 데이터값을 비교한다. 데이터 타입에서 기본형과 참조형의 차이를 생각해보면 알 수 있다. 따라서 문자의 내용을 정확하게 비교할 경우엔 `.equals()`메소드를 사용하는 게 좋다.

```arduino
String s = new String("hello");
String s2 = new String("hello");
System.out.println(s==s2);//falseboolean result = s.equals(s2);//내용비교
System.out.println(result);//true
```

```arduino
        String n = "hello";
        String n2 = "hello";
        System.out.println(n==n2);//true
        System.out.println(n.equals(n2));//true
```

### **7. 중첩 if문**

**중첩 if문**은 **if문의 블럭 내에또 다른 if문을 포함시키는 것**을 말하며,중첩의 횟수는 제한이 없습니다.

### **8. 중첩 if문 예제**

![https://blog.kakaocdn.net/dn/bei2d9/btqSZwmiZAA/8oHdOqvYiUpoktcuvZ1r4K/img.png](https://blog.kakaocdn.net/dn/bei2d9/btqSZwmiZAA/8oHdOqvYiUpoktcuvZ1r4K/img.png)

예제 4_5

### **9. switch문**

**switch문**은 **단 하나의 조건식으로많은 경우의 수를 처리**할 수 있으며,간결하여 알아보기 쉬우나,

**제약조건이 존재**합니다.s**witch문의 구조**는

![https://blog.kakaocdn.net/dn/S58xL/btqSX7fXzeh/rxfOOM96PkmwKtFIYSDtQ1/img.png](https://blog.kakaocdn.net/dn/S58xL/btqSX7fXzeh/rxfOOM96PkmwKtFIYSDtQ1/img.png)

**switch문의 처리 과정**은

아래와 같습니다.

**① 조건식을 계산합니다.**

**② 조건식의 결과와 일치하는**

**case문으로 이동합니다.**

**③ 해당하는 문장을 수행합니다.**

**④ break문이나 switch문의 끝을 만나면,**

**switch문 전체를 빠져나갑니다.**

만약, 조건식의 결과와 일치하는 case문이없는 경우, default문으로 이동

### **10. switch문의 제약조건**

**① switch문의 조건식의 결과는정수 또는 문자열이어야 합니다.**

**② case문의 값은 정수, 상수(문자 포함),문자열만 가능하며, 중복되지 않아야 합니다.**

### **11. switch문의 제약조건 예제**

**"현재 몇 월인지 입력받아서**

**해당하는 계절을 출력하는 코드"**

![https://blog.kakaocdn.net/dn/ctWDrZ/btqS6XJFIWL/dnqWLRrKYCqgpMPKJjqNWK/img.png](https://blog.kakaocdn.net/dn/ctWDrZ/btqS6XJFIWL/dnqWLRrKYCqgpMPKJjqNWK/img.png)

예제 4_6

## **switch문**

다중 if ~ else 문과 비슷하다. 일치하는 값을 비교하는 동등비교로 사용되며 표현식에 지정 가능한 데이터형은 `byte , short , int , char , String , enum` 6개다.

```arduino
public class switchTest {

    public static void main(String[] args) {

        System.out.println("점수 입력하시오");
        int num = 10;
        switch(num) {
        case 10 : System.out.println("10"); break;
        case 20 : System.out.println("20"); break;
        case 30 : System.out.println("30"); break;
        case 40 : System.out.println("40"); break;
        default : System.out.println("default");
        }
        System.out.println("프로그램 종료");

    }

}
```

일치하는 값이 없을 땐 else처럼 default문을 실행한다. `break;`을 만나면 switch문을 빠져나온다. break을 case 마다 걸어두면 문장이 하나씩 출력되는데, break를 생략할 경우 모든 문장이 한꺼번에 출력된다. 비교문으로 잘 사용하려면 break를 붙여야한다.

### **12. 임의의 정수만들기 Math.random( )**

**임의의 수(난수)를 얻기 위해**

**Math.random()을 사용**합니다.이 메서드는 **0.0과 1.0사이 하나의 double값을 반환**합니다.

### **0.0 < Math.random() < 1.0**

**ex) 1부터 10사이 임의의 정수 구하기**

① 각 변에 10을 곱한다.

*_0.0 < Math.random()_10 < 10.0__

② 각 변을 int형으로 변환한다.

*_0 <= (int)(Math.random()_10) < 10__

③ 각 변에 1을 더한다.

*_1 <= (int)(Math.random()_10)+1 < 11__

![https://blog.kakaocdn.net/dn/TnTJP/btqS4NtOpqU/YskBNGcUDwVGyBcMwBrBBk/img.png](https://blog.kakaocdn.net/dn/TnTJP/btqS4NtOpqU/YskBNGcUDwVGyBcMwBrBBk/img.png)

예제 4_7

### **13. for문**

**반복문**은 **어떤 작업이 반복적으로 수행되도록 할 때 사용**하며,**반복문의 종류**는 **for문, while문,**그리고 **do-while문**이 있습니다.**for문과 while문의 구조와 기능이 유사**하여 서로 변환이 가능하며,**반복 횟수를 알고 있는 경우**에는**for문을 사용함**

# **반복문**

조건에 따라서 특정 실행문을 반복수행한다.

**for문**

```
    for( 초기식 ; 조건식 ; 증감식 ) {
    문장1;
    }
    문장2;
```

변수에 값을 저장해 초기화하고 조건을 지정한 뒤 무한 반복에 빠지지 않도록 증감연산자를 붙인다. 이 조건식을 만족하지 않을 때까지 괄호 안의 문장1을 반복한다. 증감식에는 전치(++n), 후치(n++) 아무거나 써도 상관없다.

```
// 1부터 100까지의 3의 배수의 총합을 구하는 for문 작성int sum = 0;
        for(int i = 1; i<=100; i++) {
            if(i%3==0) {
            sum += i;
            }
        }System.out.println(sum);//1683
```

```
// 나의 틀린 문장int sum = 0;
        for(int i = 1; i<=100; i++) {
            if(i%3==0) {
            System.out.println(sum = sum+ i);
            }
        }

```

i 만 출력해보니 반복문에는 오류가 없는 걸 확인하고 총합에서 잘못되었다는 걸 알았다. 합계를 출력하는 프린트문을 반복문 괄호 안에 넣어서 여러 행이 반복 출력되었다. 따라서 반복문 괄호를 빠져나온 뒤 프린트문을 출력해야 한다. 반복문에서 프린트문의 위치가 틀리지 않았는지 잘 봐야한다.

```
// 0부터 짝수 출력하기for (int i=0; i<5; i+=2) {
    System.out.println("hello "+i);
}

---------
hello 0
hello 2
hello 4
```

```
// 10부터 1까지 역순 출력하기for(int i2=10; i2>0; i2--) {
    System.out.println("world"+i2);
}

---------
world10
world9
world8
world7
world6
world5
world4
world3
world2
world1
```

```
// 0부터 4까지 출력하기for(int i3=0; i3<5; i3++) {
    System.out.println("hello" +i3);
}

--------
hello0
hello1
hello2
hello3
hello4
```

```
// 변수 두개로 반복문 만들기int i = 0, j = 0;
        for (i = 0, j = 0; i < 5 && j < 3; i++, j++) {
            System.out.println("happy " + i);
        }
        System.out.println(i);

//&&연산자는 두 조건이 모두 t일때 t반환//i값은 3에서 빠져나왔으니 3으로 출력//만약 조건이 || 가 되면 i는 0부터 4까지 갈테니까 5가 출력될것.

---------
happy 0
happy 1
happy 2
3
```

i가 5보다 작고 j가 3보다 작은 두 가지 조건이 모두 참이어야 반복문이 실행된다. j가 2일때까지만 실행되고 j가 3으로 넘어가면 조건이 false라서 반복문이 끝난다. 두 변수 모두 초기값이 같고 똑같이 증가하기 때문에 j가 2일 때 i도 2까지만 도달하게 된다. 따라서 출력은 0,1,2 이렇게만 나온다.

```
// 1~10에서 홀수짝수 구하기int evensum = 0;// 짝수int oddsum = 0;// 홀수for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) {
                System.out.println(i + "=짝수");
                evensum += i;
            } else {
                System.out.println(i + "=홀수");
                oddsum += i;
            }
        }
```

```
//1~10에서 홀수의 합계 구하기int total = 0;
        for(int n=1; n<=10; n+=2) {
            total += n;
        }
        System.out.println("총 합계는 "+ total);//25
```

토탈이라는 빈 통에 홀수값들이 뽑힐 때마다 계속 더해주면 총합이 나온다. 값을 누적시킬 용도로 for문 위에 total을 선언하고 비어있게 0으로 초기화해야 한다. 메소드 내에 선언한 로컬변수는 반드시 사용전 초기화하기 규칙이 있었다.

### **(1) for문의 구조와 수행순서**

**for문의 구조와 수행순서**

![https://blog.kakaocdn.net/dn/E9Xx3/btqSX7mLD95/yUCKLrSN4bHoX7qkXPVxOK/img.png](https://blog.kakaocdn.net/dn/E9Xx3/btqSX7mLD95/yUCKLrSN4bHoX7qkXPVxOK/img.png)

for문의 구조와 수행순서

### **(2) 초기화**

반복문에 사용될 변수를초기화하는 부분이며,처음 한번만 수행

### **(3) 조건식**

조건식이 **참(true)이면 반복을 계속**하고,거**짓(false)이면 반복을 중단**하고,for문을 벗어남.

### **(4) 증감식**

반복문을 제어하는 **변수의 값을 증가 또는 감소시기는 식**

![https://blog.kakaocdn.net/dn/c1JMbd/btqS29D45Qj/OTlsEKiBES1NyT7DuwOoH1/img.png](https://blog.kakaocdn.net/dn/c1JMbd/btqS29D45Qj/OTlsEKiBES1NyT7DuwOoH1/img.png)

예제 4_8

### **14. for문 예제**

**"1부터 5까지 세로로 한 번 가로로 한 번 출력하는 코드"**

![https://blog.kakaocdn.net/dn/cbjfIo/btqS9ZHcLHf/qBaYXsN7ZpeV7Q9spiFxiK/img.png](https://blog.kakaocdn.net/dn/cbjfIo/btqS9ZHcLHf/qBaYXsN7ZpeV7Q9spiFxiK/img.png)

예제 4_9

**"1부터 5까지 합을 출력하는 코드"**

![https://blog.kakaocdn.net/dn/HPM2m/btqSXjHHLj0/Ko9ddLAEZr0wLyKc2kwsu1/img.png](https://blog.kakaocdn.net/dn/HPM2m/btqSXjHHLj0/Ko9ddLAEZr0wLyKc2kwsu1/img.png)

예제 4_10

### **15. 중첩 for문**

**for문 안에 또 다른 for문을**

**포함시키는 것**을 **중첩 for문**이라고 하며,중첩 횟수에는 제한이 없다.

![https://blog.kakaocdn.net/dn/yZuOP/btqS6Yhu0qH/0ylTxfZLfcpxDXt9AHOJHK/img.png](https://blog.kakaocdn.net/dn/yZuOP/btqS6Yhu0qH/0ylTxfZLfcpxDXt9AHOJHK/img.png)

예제 4_11

**16. while문**

**while문의 구조와 수행순서**는 아래와 같다.

![https://blog.kakaocdn.net/dn/cD9V3z/btqS295bpNH/blkVRFQ3rPEk0OR6TMkd20/img.png](https://blog.kakaocdn.net/dn/cD9V3z/btqS295bpNH/blkVRFQ3rPEk0OR6TMkd20/img.png)

while문의 구조와 수행순서

**① 조건식이 참(true)이면, 블럭{ }안으로 거짓(false)이면, while문 밖으로 벗어난다.**

**② 블럭{ }의 문장을 수행하고다시 조건식으로 돌아간다.**

**while문**

```
초기식;
while(조건식){
문장;
증감식;
}
```

while문은 조건식을 기술할 위치만 정해져 있어서 초기식과 증감식은 적당한 위치에 넣어줘야한다. 반복횟수가 정해져있거나 결과를 예측하기 쉽다면 for문을 사용하고, 그렇지 않다면 while문을 사용한다.

```
// 0~4까지 출력하기int n = 0;
        while(n<5) {
            System.out.println("hello "+n);
            n++;
        }
```

```
// 0~10까지의 합 구하기int i = 1, sum = 0;
        while(i<=10) {
            sum += i;
            i++;
        }System.out.println(sum);
```

중**첩 for문**

```
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 4; j++) {
        System.out.println(i + "\\t+" + j);
    }
}

------------
0    +0
0    +1
0    +2
0    +3
1    +0
1    +1
1    +2
1    +3
.....
```

1번 for 조건이 맞으면 2번 for문으로 내려온다. 2번에서 모든 반복을 다 수행하면 다시 1번으로 가서 증가한 숫자를 데리고 2번에 내려가서 다시 조건을 수행한다. 1번이 끝나면 모든 반복문이 종료된다.

```
//구구단 출력하기for (int i = 2; i < 10; i++) {
    for (int j = 1; j < 10; j++) {
        System.out.println(i + " * " + j + "\\t" + (i * j));
    }
}
```

i는 2~9까지 출력되고 j는 1~9까지 출력된다. 서로 숫자가 하나씩 증가되며 프린트문에서 i*j 연산을 붙여 최종출력한다. 여러 행을 출력하는 게 목적이니까 프린트문은 중첩for문 안에 들어가야 한다.

```
// 1~5까지 한줄로 3행 출력하기

for (int i = 1; i <= 3; i++) { //3줄 실행
    for (int j = 1; j <= 5; j++) {  //5까지의 숫자 출력
        System.out.print(j);
    }
    System.out.println();  //줄바꿈
}

---------
12345
12345
12345
```

12345를 온전히 한줄에 출력하고(print) 줄바꿈(println)하기 위해서 j가 있는 반복문 밖에 println()을 써줘야 한다.

```
// * 여러줄 출력하기for (int i = 1; i <= 5; i++) {//5줄 실행for (int j = 1; j <= i; j++) {
        System.out.print("* ");//5개의 *출력
    }
    System.out.println();//줄바꿈
}
```

중첩반복문의 꽃, 별출력하기. 만약 j≤5 로 조건을 놓으면 별은 5개씩 5행이 출력된다. 근데 j≤i 로 놓으면 i가 1에서 내려올 때 j도 1만큼 출력한다. 2면 2개. 이렇게 i의 증감값을 그대로 받으니까 계단형으로 출력이 된다. 만약 거꾸로 커졌다가 내려오는 별출력을 하려면 i는 5에서 시작해서 1까지 내려오는 감소연산 문장을 쓰면 된다.

```
// 10부터 1까지 거꾸로 출력하기for (int i = 10; i >= 1; i--) {
    for (int j = 10; j >= i; j--) {
        System.out.print(j);
    }
    System.out.println();
}
```

### **17. while문 예제1**

**"변수 i의 값만큼 블럭{}을 반복하는 코드"**

![https://blog.kakaocdn.net/dn/dxLHcU/btqS3aXjZl8/iDO0lyQnkp5Sk8HOQXCzA1/img.png](https://blog.kakaocdn.net/dn/dxLHcU/btqS3aXjZl8/iDO0lyQnkp5Sk8HOQXCzA1/img.png)

예제 4_12

**"1부터 몇까지 더해야 100을넘지 않는지 알아내는 코드"**

![https://blog.kakaocdn.net/dn/daOCzZ/btqS4LJt0UD/rOkmH2j4tk1HX50O5rKMn1/img.png](https://blog.kakaocdn.net/dn/daOCzZ/btqS4LJt0UD/rOkmH2j4tk1HX50O5rKMn1/img.png)

예제 4_13

### **18. while문 예제2**

**"사용자로부터 숫자를 입력받고, 이 숫자의 각 자리의 합을 구하는 코드"**

![https://blog.kakaocdn.net/dn/dYANwi/btqSZxZSZW4/AkKMbOE3MZepMsdTMgoRJK/img.png](https://blog.kakaocdn.net/dn/dYANwi/btqSZxZSZW4/AkKMbOE3MZepMsdTMgoRJK/img.png)

예제 4_14

### **19. do-while문**

**do-while문**은 **while문에서 조건식과 블럭{ }의 순서를 바꾼 것**이며,while문과는 **달리 블럭{ }을 먼저 수행한 후 ,조건식을 평가**

그래서 **do-while문은 최소한 한번은 블럭{ }이 수행**

**do~while문**

do에서 문장을 먼저 실행하고 그 다음 조건을 붙인다. 따라서 조건을 먼저 보는 while문과 다르게 적어도 한 번은 문장이 수행된다.

```
// 문자 4번 출력하기int n = 0;
        do {
            System.out.println("world");
            n++;
        } while (n < 5);

// 맨처음 실행할때 조건이 없음. 무조건 실행됨.// while은 조건 먼저 거치기때문에 실행이 안 될 가능성있다.
```

```
// 짝수출력int a = 2;
        do {
            System.out.println(a);
            a += 2;
        } while (a <= 10);
```

![https://blog.kakaocdn.net/dn/bpsfwG/btqSZwmjlIx/A4oS5DSnmHYkY6PYBJNDak/img.png](https://blog.kakaocdn.net/dn/bpsfwG/btqSZwmjlIx/A4oS5DSnmHYkY6PYBJNDak/img.png)

예제 4_15

### **20. break문**

**break문**은 ****주로 **if문과 함께 사용되어 특정 조건을 만족할 때, 반복문을 벗어나게 합니다.**

![https://blog.kakaocdn.net/dn/NbsU8/btqSXiPztqp/sUp7rOV6aLPDNQMlkm4YK1/img.png](https://blog.kakaocdn.net/dn/NbsU8/btqSXiPztqp/sUp7rOV6aLPDNQMlkm4YK1/img.png)

**break문**

```
        int n = 1;
        while(n<=10) {
            System.out.println(n+"Hello World");
            n++;
            if(n==8) break;//n이 8이 되는 순간 반복문 빠져나옴
        }
        System.out.println(n);
```

실행중인 반복문을 중지할 때 break문을 사용한다.

```java
A : for(int i=0; i<5; i++) {
		for(int j=0; j<4; j++) {
			System.out.println(i + "\\t"+ j);
			if(i==3) break A;
		}
	}
```

중첩반복문에서 사용하는 경우 가장 가까운 반복문에서 break가 적용되는데, 특정 반복문을 빠져나오고 싶다면 라벨을 활용하면 된다. 반복문 맨 위에 `라벨:` 을 표시해주고 원하는 위치에 `break 라벨;` 을 책갈피처럼 적어준다.

예제 4_16

### **21. continue문**

**continue문**은 **반복문에서만 사용이 가능**하며, 반복이 진행되는 도중에 **continue를 만나면**

**끝으로 이동하여 다음 반복**으로 넘어간다. **for문**은 **증감식**으로,**while문과 do-while문**은 **조건식**으로 이동합니다.

![https://blog.kakaocdn.net/dn/Bbw58/btqS6X3XZr5/kwDzbd0oxibkfWoZoagyPk/img.png](https://blog.kakaocdn.net/dn/Bbw58/btqS6X3XZr5/kwDzbd0oxibkfWoZoagyPk/img.png)

예제 4_17

**continue문**

continue를 걸어둔 부분에서 다음 문장을 수행하지 말고 다시 반복문 처음으로 돌아가서 반복 실행하라는 의미다.

```java
			for(int i=0; i<5; i++) {
			System.out.println("Hello1 "+i);
			System.out.println("Hello2 "+i);
			if(i==3)continue;
			System.out.println("Hello3 "+i);
			System.out.println("Hello4 "+i);
```

순차적으로 프린트가 실행되다가 i가 3인 경우엔 헬로1,2 까지만 출력되고 다시 올라간다. 4는 정상출력 된다.

```java
//1부터 10까지에서 홀수값만 출력for (int i = 0; i < 10; i++) {
				if (i % 2 == 0) continue;
				System.out.println("홀수값 : " + i);
			}
```

1~10까지 반복문을 실행하면서 짝수만 생략할 수 있도록 짝수 조건에 컨티뉴를 걸어준다.

### **22. break문과 continue문 예제**

**"메뉴를 보여주고 선택하게 하는 코드"**

![https://blog.kakaocdn.net/dn/b08hrL/btqS4Mhm9OT/s9phqhYF47A8NUdqv9i8z0/img.png](https://blog.kakaocdn.net/dn/b08hrL/btqS4Mhm9OT/s9phqhYF47A8NUdqv9i8z0/img.png)

예제 4_18

### **23. 이름 붙은 반복문**

중첩된 반복문 앞에 이름을 붙이고, break문과 continue문에 이름을 지정하여 **하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.**

![https://blog.kakaocdn.net/dn/bvflnc/btqTcQ4ixvs/PlETF6Z0jcVmCLZ29f2kS0/img.png](https://blog.kakaocdn.net/dn/bvflnc/btqTcQ4ixvs/PlETF6Z0jcVmCLZ29f2kS0/img.png)

예제 4_19

### **24. 이름 붙은 반복문 예제**

**"여러 연산 중 하나를 선택하면**

**해당 연산을 반복적으로 수행하는 코드"**

![https://blog.kakaocdn.net/dn/NTT3s/btqS4NAyNIs/TDrSVBxkrKBFltHkdkW2K1/img.png](https://blog.kakaocdn.net/dn/NTT3s/btqS4NAyNIs/TDrSVBxkrKBFltHkdkW2K1/img.png)

예제 4_20 코드

![https://blog.kakaocdn.net/dn/u4rI4/btqS9ZNX2DG/EFBYgfQdDbTrknIHXz8QLk/img.png](https://blog.kakaocdn.net/dn/u4rI4/btqS9ZNX2DG/EFBYgfQdDbTrknIHXz8QLk/img.png)

예제 4_20 결과

### **연습문제**

# 4-1. 다음의 문장들을 조건식으로 표현하라

1.  int x 10 20 true 형 변수 가 보다 크고 보다 작을 때 인 조건식
2.  char ch true 형 변수 가 공백이나 탭이 아닐 때 인 조건식
3.  char ch ‘x' ’X' true 형 변수 가 또는 일 때 인 조건식
4.  char ch 형 변수 가 숫자(‘0’~‘9’)일 때 인 조건식 true
5.  char ch ( ) true 형 변수 가 영문자 대문자 또는 소문자 일 때 인 조건식
6.  int year 400 4 100 형 변수 가 으로 나눠떨어지거나 또는 로 나눠떨어지고 으로 나눠떨어지지 않을 때 인 조건식 true
7.  boolean powerOn false true 형 변수 가 일 때 인 조건식
8.  str “yes” true 문자열 참조변수 이 일 때 인 조건식

```
publicclassPractice01 {
publicstaticvoidmain(String[] args) {
// 1int x = 15;
        System.out.println(x > 10 && x < 20);

// 2char ch = 'a';
        System.out.println(!(ch == ' ' || ch=='\\t'));

// 3
        ch = 'x';
        System.out.println(ch == 'x' || ch == 'X');

// 4
        ch = '0';
        System.out.println(ch >= '0' && ch <= '9');

// 5
        ch = 'a';
        System.out.println((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));

// 6int year = 2000;
        System.out.println(year % 400 == 0 || year % 4 == 0 && year % 100 !=0);

// 7boolean powerOn =false;
        System.out.println(!powerOn);

// 8
        String str = "yes";
        System.out.println(str.equals("yes"));
    }
}
```

# 4-2. 1부터 20까지의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.

```
publicclassPractice02 {
publicstaticvoidmain(String[] args) {
int sum = 0;
for (int i = 1; i <= 20; i++) {
if (i % 2 != 0 || i % 3 != 0) {
                sum += i;
            }
        }
        System.out.println(sum);
    }
}
```

# 4-3. 1+(1+2)+(1+2+3)+(1+2+3+4)+...+(1+2+3+...+10)의 결과를 계산하시오.

```
publicclassPractice03 {
publicstaticvoidmain(String[] args) {
int sum = 0;
for (int i = 1; i <= 10; i++) {
for (int j = 1; j <= i; j++){
                sum += j;
            }
        }
        System.out.println(sum);
    }
}
```

# 4-4. 1+(-2)+3+(-4)+... 과 같은 식으로 계속 더해나갔을 때, 몇까지 더해야 총합이 100이상이 되는지 구하시오.

```
publicclassPractice04 {
publicstaticvoidmain(String[] args) {
int sum = 0;
for (int i = 1;;i++) {
if(i % 2 == 0){
                sum -= i;
            }else{
                sum += i;
            }
if(sum >= 100){
                System.out.println(i);
break;
            }
        }
    }
}
```

# 4-5. 다음의 for문을 while문으로 변경하시오.

```
publicclassExercise4_5 {
publicstaticvoidmain(String[] args) {
for(int i=0; i<=10; i++) {
for(int j=0; j<=i; j++)
                System.out.print("*");
            System.out.println();
        }
    }// end of main
}// end of class
```

```
publicclassPractice05 {
publicstaticvoidmain(String[] args) {
int i = 0;
while (i <= 10) {
int j = 0;
while (j <= i) {
                System.out.print("*");
                j++;
            }
            System.out.println();
            i++;
        }
    }
}
```

# 4-6. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하는 프로그램을 작성하시오.

```
publicclassPractice06 {
publicstaticvoidmain(String[] args) {
for (int i = 1; i <= 6; i++) {
for (int j = 1; j <= 6; j++) {
if (i + j > 6) {
break;
                }elseif(i + j == 6){
                    System.out.println(i + " " + j);
                }
            }
        }
    }
}
```

# 4-7. Math.random()을 이용해서 1부터 6사이의 임의의 정수를 변수 value에 저장하는 코드를 완성하라.

```
publicclassPractice07 {
publicstaticvoidmain(String[] args) {
int value = (int)(Math.random() * 6) + 1;
        System.out.println(value);
    }
}
```

# 4-8. 방정식 2x+4y=10의 모든 해를 구하시오. 단, x와 y는 정수이고 각각의 범위는 0<=x<10, 0<=y<=10 이다.

```
publicclassPractice08 {
publicstaticvoidmain(String[] args) {
for (int x = 0; x < 11; x++) {
for (int y = 0; y < 11; y++) {
if (2 * x + 4 * y == 10) {
                    System.out.println("x = " + x + ", y = " + y);
                }
            }
        }
    }
}
```

# 4-9. 숫자로 이루어진 문자열 str이 있을 때, 각 자리의 합을 더한 결과를 출력하는 코드를 완성하라. 만일 문자열이 "12345"fkaus, '1+2+3+4+5"의 결과인 15를 출력이 출력되어야 한다.

```
publicclassPractice09 {
publicstaticvoidmain(String[] args) {
        String str = "12345";
int sum = 0;
for (String number : str.split("")){
            sum += Integer.parseInt(number);
        }
        System.out.println("sum = " + sum);
    }
}
```

# 4-10. int num , 타입의 변수 이 있을 때 각 자리의 합을 더한 결과를 출력하는 코드를 완성하라 만일 변수 의 값이 라면 . num 12345 , ‘1+2+3+4+5’ 15 의 결과인 를 출력하라.

```
publicclassPractice10 {
publicstaticvoidmain(String[] args) {
int number = 12345;
int sum = 0;

while(number > 0){
            sum += number % 10;
            number /= 10;
        }
        System.out.println("sum = " + sum);
    }
}
```

# 4-11. 피보나치(Fibonnaci) 수열은 앞을 두 수를 더해서 다음 수를 만들어 나가는 수열이다. 예를 들어 앞의 두 수가 1과 1이라면 그 다음 수는 2가 되고 그 다음 수는 1과 2를 더해서 3이 되어서 1,1,2,3,5,8,13,21... 과 같은 식으로 진행된다. 1과 1부터 시작하는 피보나치수열의 10번째 수는 무엇인지 계산하는 프로그램을 완성하시오.

```
publicclassPractice11 {
publicstaticvoidmain(String[] args) {
int num1 = 1;
int num2 = 1;
int num3 = 0;

        System.out.print(num1 + "," + num2);

for (int i = 0; i < 8; i++){
            num3 = num1 + num2;
            System.out.print(num3 +",");
            num1 = num2;
            num2 = num3;
        }
    }
}
```

# 4-12. 구구단의 일부분을 출력하시오.

```
publicclassPractice12 {
publicstaticvoidmain(String[] args) {
for (int i = 2; i < 8; i++) {
for (int j = 1; j < 4; j++) {
                System.out.print(i + " * " + j + " = " + i * j + "\\t");
            }
            System.out.println();
        }
    }
}
```

# 4-13. 주어진 문자열이 숫자인지를 판별하는 프로그램을 완성하시오.

```
publicclassPractice13 {
publicstaticvoidmain(String[] args) {
        String value = "12o34";
char ch = ' ';
boolean isNumber =true;

for (int i = 0; i < value.length(); i++) {
            ch = value.charAt(i);
if(!(ch >= '0' && ch <='9')){
                isNumber =false;
break;
            }
        }

if(isNumber){
            System.out.println(value + "는 숫자입니다.");
        }else{
            System.out.println(value + "는 숫자가 아닙니다.");
        }
    }
}
```

# 4-14. 숫자 맞추기 게임을 만들자. 1과 100사이의 값을 반복적으로 입력해서 컴퓨터가 생각한 값을 맞추면 게임은 끝난다. 사용자가 값을 입력하면, 컴퓨터는 자신이 생각한 값과 비교해서 결과를 알려준다. 사용자가 컴퓨터가 생각한 숫자를 맞추면 게임이 끝나고 몇 번만에 숫자를 맞췄는지 알려준다.

```
import java.util.Scanner;

publicclassPractice14 {
publicstaticvoidmain(String[] args) {
        Scanner scanner =new Scanner(System.in);
int computerNumber = (int)(Math.random() * 100) + 1;
int userNumber = 0;
int trial = 0;
while(userNumber != computerNumber){
            System.out.println("1과 100사이의 값을 입력하세요.");
            userNumber = scanner.nextInt();
if(userNumber > computerNumber){
                System.out.println("더 작은 수를 입력하세요.");
            }else{
                System.out.println("더 큰수를 입력하세요.");
            }
            trial++;
        }
        System.out.println("맞췄습니다.\\n시도횟수는 " + trial + "번입니다.");
    }
}
```

# 4-15. 회문수를 구하는 프로그램을 작성한다. 회문수(palindrome)란, 숫자를 거꾸로 읽어도 앞으로 읽는 것과 같은 수를 말한다. 예를 들면 '12321'이나 '13531'같은 수를 말한다.

```
publicclassPractice15 {
publicstaticvoidmain(String[] args) {
int number = 12321;
int temp = number;

int result = 0;

while(temp !=0){
            result = result * 10 + temp % 10;
            temp /= 10;
        }

if(number == result){
            System.out.println(number + "는 회문수 입니다.");
        }else{
            System.out.println(number + "는 회문수가 아닙니다.");
        }
    }
```


